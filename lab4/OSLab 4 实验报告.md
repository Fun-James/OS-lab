**姓名**： 张奥喆（2313447） 余俊辉（2313486） 杨李泽（2313851）

***

# 练习1：分配并初始化一个进程控制块（需要编码）

## 1. 代码实现

在 `alloc_proc` 函数中，我们需要将 `proc_struct` 的各个成员变量初始化为默认值。根据 `proc_init` 函数中的检查逻辑，我们可以确定大部分字段的初始值。

```c++
static struct proc_struct *
alloc_proc(void)
{
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL)
    {
        proc->state = PROC_UNINIT;      // 设置进程状态为未初始化
        proc->pid = -1;            
        proc->runs = 0;              
        proc->kstack = 0;         
        proc->need_resched = 0;        
        proc->parent = NULL;         
        proc->mm = NULL;          
        memset(&(proc->context), 0, sizeof(struct context));
        proc->tf = NULL;              
        proc->pgdir = boot_pgdir_pa;    // 页目录表基址设为内核页目录表
        proc->flags = 0;            
        memset(proc->name, 0, PROC_NAME_LEN + 1); 
    }
    return proc;
}
```

## 2. 设计实现过程简述

* **内存清空**：对于 `context`、`name`等结构体或数组，使用 `memset` 进行清零，防止残留数据影响。对于指针类型如 `parent`, `mm`, `tf`，显式赋值为 `NULL`。

* **状态初始化**：

  * `state` 设为 `PROC_UNINIT`，表明该进程结构体已分配但未完成构建。

  * `pid` 设为 `-1`，因为 PID 的分配是在 `do_fork` 中通过 `get_pid` 完成的。

* **页表设置**：

  * `pgdir` 设为 `boot_pgdir_pa`，即内核页目录物理地址。这是因为所有进程在创建之初都需要能访问内核空间，且 `proc_init` 中的校验代码明确要求了这一初始值。

## 3. context 和 tf 的含义与作用

* **struct context context&#x20;**

1. **含义**：`context` 保存的是进程切换时的寄存器状态。

2. **作用**：

   * **内核态切换**：它主要用于 `switch_to` 函数中。当调度器决定暂停当前进程并运行另一个进程时，它会保存当前进程的“被调用者保存寄存器”（如 `s0`-`s11`, `ra`, `sp`）到其 `context` 中。

   * **恢复执行**：当该进程再次被调度选中时，内核会从 `context` 中恢复这些寄存器，使得进程能够从上次被挂起的地方继续执行，就像从未中断过一样。

   * **新进程入口**：对于新创建的进程，`copy_thread` 函数会伪造一个 context，将其 `ra` 设置为 `forkret`，`sp` 设置为内核栈顶。这样当新进程第一次被 `switch_to` 选中时，它会跳转到 `forkret` 开始执行。

* **struct trapframe \*tf&#x20;**

1. **含义**：`trapframe` 保存的是发生中断、异常或系统调用瞬间的完整 CPU 状态。

2. **作用**：

   * **用户态/内核态切换**：当进程从用户态进入内核态时，硬件和底层汇编会将所有通用寄存器、程序计数器（epc）、状态寄存器（sstatus）等压入内核栈，形成一个 `trapframe`。`proc->tf` 指向这个结构。

   * **系统调用传参**：用户态传递的系统调用参数（如 `a0`, `a1` 等）存储在 `tf` 中，内核通过读取 `tf` 来获取参数。

   * **构造新线程**：在创建新进程时，内核会复制父进程的 `tf` 给子进程，并修改其中的 `a0` 寄存器为 0，以及设置 `sp`。这使得子进程在被调度执行并从 `forkrets` 返回时，看起来像是刚从一个系统调用中返回一样。

***

# 练习2：为新创建的内核线程分配资源（需要编码）

## 1. 设计实现过程简述

`do_fork` 函数是 uCore 中创建新进程/线程的核心函数。其主要职责是为新进程分配资源，复制父进程的状态，并将其纳入内核的调度管理中。整个执行流程可以总结为以下几个关键步骤：

1. **资源分配**：首先调用 `alloc_proc` 分配一个 `proc_struct` 结构体，作为新进程的进程控制块（PCB）。

2. **建立关系**：将当前进程设置为新进程的父进程，构建进程树。

3. **内核栈配置**：调用 `setup_kstack` 为新进程分配 2 页（8KB）大小的内核栈。这是进程在内核态执行时的堆栈空间，用于保存上下文和函数调用链。

4. **内存空间处理**：调用 `copy_mm`。

   * 对于 `kernel_thread` 创建的内核线程，通常共享内核空间的页表，因此 `proc->mm` 为 NULL（或通过 `CLONE_VM` 共享）。

   * 如果是用户进程 `fork`，则需要复制 `mm_struct` 和页表，实现地址空间的隔离（或写时复制）。

5. **上下文设置（关键）**：调用 `copy_thread`。它在内核栈的栈顶设置了中断帧（`trapframe`）和进程上下文（`context`）。

   * `context.ra` 被设置为 `forkret` 函数的入口地址。

   * `context.sp` 指向刚才设置好的 `trapframe` 的地址。

   * **目的**：当该进程第一次被 `switch_to` 调度时，CPU 会跳转到 `forkret`，然后从中断帧恢复寄存器，最终进入线程的入口函数。

6. **全局状态更新（原子操作）**：为了保证多进程环境下的数据一致性，在操作全局进程链表 `proc_list` 和哈希表 `hash_list` 时，需要使用 `local_intr_save` 关闭中断。在此临界区内，调用 `get_pid` 获取唯一 PID，并将新进程加入管理链表。

7. **状态就绪**：最后调用 `wakeup_proc` 将进程状态设置为 `PROC_RUNNABLE`，使其可以被调度器选中执行。

## 2. 代码实现

我们将 `do_fork` 的具体代码实现拆解为以下 7 个步骤进行解析：

**第一步：分配进程控制块 (PCB)** 首先调用 `alloc_proc` 为新进程分配一个 `proc_struct` 结构体，如果内存不足则返回错误。

```c
    // 1. 分配并初始化进程控制块 (PCB)
    if ((proc = alloc_proc()) == NULL) {
        goto fork_out;
    }
```

**第二步：建立父子关系** 将当前进程（`current`）设置为新进程的父进程，建立进程树关系。

```c
    // 2. 设置父进程
    proc->parent = current;
    // 确保在 fork 处理期间，wait 状态的父进程不会被调度
    assert(proc->wait_state == 0); 
```

**第三步：分配内核栈** 调用 `setup_kstack` 为新进程分配 2 页（8KB）的内核栈空间，这是进程在内核态执行时的堆栈。

```c
    // 3. 分配并初始化内核栈
    if (setup_kstack(proc) != 0) {
        goto bad_fork_cleanup_proc;
    }
```

**第四步：内存管理结构处理** 调用 `copy_mm` 复制或共享内存管理结构。对于本实验中的内核线程（如 `initproc`），它们通常共享内核页表，因此 `mm` 为 NULL。

```c
    // 4. 复制或共享内存管理结构 (mm)
    if (copy_mm(clone_flags, proc) != 0) {
        goto bad_fork_cleanup_kstack;
    }
```

**第五步：设置中断帧与上下文** 这是最关键的一步。调用 `copy_thread` 在新分配的内核栈顶设置中断帧（`tf`）和上下文（`context`）。

* `context.ra` 被设为 `forkret`，确保进程被调度后跳转到 `forkret`。

* `context.sp` 指向 `trapframe`，确保中断返回时能恢复寄存器。

```c
    // 5. 设置进程的中断帧 (trapframe) 和上下文 (context)
    copy_thread(proc, stack, tf);
```

**第六步：原子地分配 PID 并加入链表** 为了保证多进程环境下的数据一致性，必须在**关中断**的状态下执行 PID 分配和链表插入操作。

* `get_pid()`：获取唯一 PID。

* `hash_proc()`：建立 PID 到 PCB 的哈希映射。

* `list_add()`：将进程加入全局进程链表。

```c
    // 6. 把新进程加入进程链表，并分配唯一的 PID
    bool intr_flag;
    local_intr_save(intr_flag); // 关中断
    {
        proc->pid = get_pid();
        hash_proc(proc);                 
        list_add(&proc_list, &(proc->list_link)); 
        nr_process++;
    }
    local_intr_restore(intr_flag); // 开中断
```

**第七步：唤醒新进程并返回** 最后，将新进程的状态设置为 `PROC_RUNNABLE`（可运行），并返回新进程的 PID 给父进程。

```c
    // 7. 唤醒新进程
    wakeup_proc(proc);

    // 8. 返回新进程的 PID
    ret = proc->pid;
```

## 3. 问题分析

### 请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。

**答案：是，ucore 能够保证给每个新 fork 的线程分配一个唯一的 ID。**

**分析与理由：**

这一机制主要是在 `get_pid()` 函数中实现的（位于 `kern/process/proc.c`）。

1. **静态计数与回绕机制**： `get_pid` 内部维护了一个静态变量 `last_pid`。每次调用时，尝试 `last_pid + 1`。如果 `last_pid` 超过了 `MAX_PID`，它会回绕重置为 1。

2. **遍历检查机制**： 仅仅自增是不够的，因为旧的 PID 可能还在被占用（例如 PID 溢出回绕的情况）。因此，`get_pid` 包含了一个严格的检查循环：

```plain&#x20;text
// 伪代码逻辑
repeat:
    if (++last_pid >= MAX_PID) last_pid = 1;
    bool pid_exist = false;
    // 遍历当前所有进程链表
    list_entry_t *list = &proc_list, *le;
    while ((le = list_next(le)) != list) {
        proc = le2proc(le, list_link);
        if (proc->pid == last_pid) {
            pid_exist = true; // 发现 PID 冲突
            break;
        }
    }
    // 如果冲突，重新自增 last_pid 并再次检查；直到找到未被占用的 PID
    if (pid_exist) goto repeat; 
```

1. 这段逻辑确保了选出的 `last_pid` 绝对不会与当前 `proc_list` 中任何一个处于活跃状态（或僵尸状态但未彻底销毁）的进程的 PID 重复。

2. **原子性保证**： 在 `do_fork` 函数中，调用 `get_pid()` 以及随后的 `hash_proc` 和 `list_add` 操作都被包裹在 `local_intr_save(intr_flag)` 和 `local_intr_restore(intr_flag)` 之间。这意味着在分配 PID 和将其注册到系统这个过程中，中断是被禁止的，不会发生进程切换。这保证了 PID 分配过程的原子性，防止了并发竞争导致的 PID 重复分配问题。

***

# 练习3：编写proc\_run 函数（需要编码）

## 1. 实验目的

实现内核线程切换的核心逻辑。`proc_run` 函数负责将 CPU 的控制权从当前进程（`current`）转移到指定的新进程（`proc`）。这涉及到上下文切换、页表切换以及中断状态的控制，是操作系统实现多任务并发执行的基础。

## 2. 设计与实现过程

### 代码实现分析

在 `kern/process/proc.c` 文件中，我完成了 `proc_run` 函数的编写。该函数的执行流程严格遵循了进程切换的原子性和一致性要求。

以下是核心代码逻辑的详细说明：

```c++
// kern/process/proc.c
 void proc_run(struct proc_struct *proc) {
     if (proc != current) {
         bool intr_flag;
         struct proc_struct *prev = current, *next = proc;
         // 屏蔽中断，保证进程切换的原子性
         local_intr_save(intr_flag);
         {
             // 1. 修改当前进程指针
             current = proc;
             // 2. 切换页表，加载新进程的页目录表基址(SATP)
             lsatp(next->pgdir);
             // 3. 进行上下文切换，保存原进程状态，恢复新进程状态
             switch_to(&(prev->context), &(next->context));
         }
         // 恢复中断状态
         local_intr_restore(intr_flag);
     }
 }
```

`proc_run` 函数是 uCore 中实现进程调度的核心函数，其主要逻辑包含以下几个关键步骤，设计思路遵循了操作系统的进程切换原理：

1. **检查目标进程 (`if (proc != current)`)**：首先判断要切换到的目标进程是否就是当前正在运行的进程。如果是同一个进程，则没有必要进行昂贵的上下文切换操作，直接返回即可，提高了调度效率。

2. **关中断 (`local_intr_save`)**：进程切换涉及修改 `current` 指针、切换页表寄存器（SATP）以及寄存器状态（switch\_to）等多个步骤。这些步骤必须构成一个**原子操作**。如果在切换过程中发生中断（例如时钟中断），可能导致系统状态不一致（例如：`current` 指向了新进程，但页表还是旧进程的），从而引发内核崩溃。因此，必须在切换期间屏蔽中断。

3. **更新当前进程指针 (`current = proc`)**：将全局变量 `current` 指向 `next` 进程。这是逻辑上的切换，标志着从操作系统管理的角度来看，当前占用 CPU 的已经是新进程了。

4. **切换页表 (`lsatp(next->pgdir)`)**：使用 `lsatp` 指令将新进程的页目录表物理地址加载到 RISC-V 的 `satp` 寄存器中，虽然在本实验中（Lab4），所有内核线程共享同样的内核虚拟地址空间（都使用 `boot_pgdir`），但这一步对于后续支持用户进程（Lab5）至关重要。它确保了 CPU 能够正确通过 MMU 翻译新进程的虚拟地址。同时，写 `satp` 寄存器通常会触发 TLB 刷新。

5. **上下文切换 (`switch_to`)**：

   * 这是实现控制流转移的关键汇编函数。它将当前 CPU 的寄存器状态（被调用者保存寄存器 `s0-s11`、栈指针 `sp`、返回地址 `ra`）保存到 `prev->context` 中。然后从 `next->context` 中恢复这些寄存器的值。

   * 当 `switch_to` 执行最后的 `ret` 指令时，CPU 会跳转到 `next->context.ra` 指向的地址（通常是 `forkret`），此时程序执行流就真正变成了新进程的代码流。

6. **开中断 (`local_intr_restore`)**：当进程被切换回来（或者新进程开始运行）后，需要恢复中断响应，以便系统能继续处理时钟中断、I/O 中断等外部事件。

### 编译适配与修正

在实验过程中，为了适配特定的编译环境或解决依赖问题，对部分代码进行了微调：

1. **头文件包含：** 在 `proc.c` 中添加了 `#include <sbi.h>`，以确保底层的 SBI 调用接口可见。

2. **类型转换修正：** 在 `__slob_free_pages` 函数中，将 `kva` 强制转换为 `void*` 指针再传入 `kva2page`，消除了编译器的类型警告，确保内存释放逻辑的正确性。

## 3. **在本实验的执行过程中，创建且运行了几个内核线程？**

在本实验（Lab 4）的执行过程中，总共创建并运行了 **2 个** 内核线程。

1. **第 0 个内核线程 (`idleproc`)：**

   * **创建方式：** 在 `proc_init` 函数中，通过手动构造的方式，将系统启动时的原始执行流初始化为第 0 号进程。

   * **作用：** 它是系统的空闲进程。当没有其他任务执行时，调度器会选择它，它执行 `cpu_idle` 函数进入死循环（等待调度）。它是所有进程链表的起点。

2. **第 1 个内核线程 (`initproc`)：**

   * **创建方式：** 在 `proc_init` 函数中，调用 `kernel_thread` 函数创建。

   * **执行流程：** `kernel_thread` 调用 `do_fork`，复制了 `idleproc` 的资源，并伪造了中断帧和上下文。

   * **作用：** 它是本实验中第一个真正执行特定任务的线程。在本实验中，它的任务是执行 `init_main` 函数，打印字符串 "Hello World!!"，以此验证进程调度机制是否工作正常。

**验证依据：** 根据实验输出日志：

```c
 this initproc, pid = 1, name = "init"
 To U: "Hello world!!".
```

可以看到 `initproc`（PID 1）被成功调度并输出了信息，而这一切的基础是 `idleproc`（PID 0）在后台进行了调度分发。

***

# 扩展练习 Challenge：

## 1. 说明语句`local_intr_save(intr_flag);....local_intr_restore(intr_flag);`是如何实现开关中断的？

### 1.1 `local_intr_save(intr_flag);` —— 保存并关闭中断

这行代码包含三个步骤的操作：

* **读取当前状态**：宏内部会读取 CPU 的**状态寄存器**。

* **保存状态**：它将读取到的中断使能位的状态保存到传入的变量 `intr_flag` 中。在 `proc_run` 函数中，`intr_flag` 被定义为 `bool` 类型，说明它只记录中断之前是“开”还是“关”。

* **关闭中断**：通过修改 `sstatus` 寄存器，将 SIE 位清零。从这一刻起，CPU 将忽略外部中断，确保接下来的代码独占 CPU 执行。

### 1.2 `local_intr_restore(intr_flag);` —— 恢复中断状态

这行代码用于退出临界区：

* **恢复状态**：它不会简单地“开启”中断，而是根据之前保存的 `intr_flag` 变量的值来恢复。

* **逻辑判断**：如果进入临界区前中断是开的（`intr_flag` 为真），那么这里会重新开启中断；如果进入临界区前中断本来就是关的，那么这里依然保持关闭状态。

* **写入寄存器**：将恢复后的状态写回 `sstatus` 寄存器。

### 1.3 结合代码中的具体应用

在提供的 `proc.c` 代码中，这两句主要用于以下两个场景：

* **场景一：`proc_run` (进程切换)**

```c
bool intr_flag;
struct proc_struct *prev = current, *next = proc;

// 1. 禁用中断（保存当前中断状态）
local_intr_save(intr_flag);
{
    // 2. 切换当前进程为要运行的进程
    current = proc;
    
    // 3. 切换页表，以便使用新进程的地址空间
    // lsatp() 函数接受页目录表的物理地址（右移 RISCV_PGSHIFT 位）
    lsatp(next->pgdir);
    
    // 4. 实现上下文切换
    // switch_to() 定义在 switch.S 中
    // 第一个参数：指向当前进程 context 的指针（保存旧进程上下文）
    // 第二个参数：指向新进程 context 的指针（恢复新进程上下文）
    switch_to(&(prev->context), &(next->context));
}
// 5. 允许中断（恢复之前的中断状态）
local_intr_restore(intr_flag);
```

这里必须关中断，因为如果在切换页表或上下文的中途发生中断，CPU 状态会处于不一致的中间态，可能导致系统崩溃。

* **场景二：`do_fork` (创建新进程)**

```c
bool intr_flag;
local_intr_save(intr_flag);  // 禁用中断，保证原子操作
{
    proc->pid = get_pid();    // 分配唯一的 PID
    hash_proc(proc);          // 加入哈希表
    list_add(&proc_list, &(proc->list_link));  // 加入进程链表
    nr_process++;             // 进程数量加1
}
local_intr_restore(intr_flag);  // 恢复中断
```

这里涉及对全局共享数据结构（`proc_list`, `hash_list`, `nr_process`）的修改。如果不关中断，多个进程同时 Fork 可能导致链表指针错乱。

## 2. 深入理解不同分页模式的工作原理

### get\_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。

`get_pte` 函数中的两段相似代码分别对应 **SV39 三级页表机制** 中**前两级页目录表**（第一级和第二级）的遍历与构建过程。

RISC-V 的 SV32（二级）、SV39（三级）和 SV48（四级）均采用**多级页表**结构，其每一级非叶节点的处理逻辑本质上是递归且一致的：**“根据虚拟地址索引当前级表项 -> 检查是否存在 -> 若不存在且允许创建，则分配物理页作为下一级页表 -> 设置映射”**。由于 SV39 拥有三级结构，从根页表出发需要经过两次这样的中间层级跳转（L2 $\to$ L1，L1 $\to$ L0）才能到达存放物理页号的最终页表项，因此代码中必然会出现两次结构相同、仅索引计算方式（`PDX1` 与 `PDX0`）不同的逻辑块；如果是四级页表的 SV48，则会出现三段类似代码。

***

### 目前get\_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

目前的这种写法是**合理且高效的**，在当前场景下**没有必要**将这两个功能完全拆开。理由如下：

1. **简化调用者的逻辑（封装复杂性）** `get_pte` 的核心功能是返回一个虚拟地址对应的页表项（PTE）指针。在多级页表机制（如 RISC-V 的 Sv39）中，获取末级 PTE 需要遍历中间各级页表（如页目录表 PDX1、PDX0）。

* 如果调用者（如 `page_insert`）想要建立映射，它**必须**保证中间层级的页表是存在的。

* 如果将“查找”和“分配”拆开，调用者就必须显式地编写多层 `if-else` 逻辑来处理中间页表的缺失和分配。

* 当前的 `get_pte` 通过 `bool create` 参数将“多级页表的遍历与按需填充”封装在内部，使得外部调用（如 `page_insert`）只需一行代码即可获得最终的 PTE，极大地简化了代码结构。

**2. `create` 标志位提供了足够的灵活性** 虽然功能合并了，但函数并没有丧失灵活性。通过 `create` 参数，函数实际上支持两种模式：

* **查询模式 (`create = 0`)**：仅查找，若中间缺失则返回 NULL。这在 `page_remove` 或查询内存状态时非常有用，避免了不必要的内存分配。

* **分配模式 (`create = 1`)**：查找并在必要时分配。这在建立映射时是必须的。 这种设计在保持接口简洁的同时，满足了读（查询）和写（映射）两种需求。

- **减少代码冗余** 在操作系统的内存管理中，遍历页表是一个极其高频的操作。如果拆分功能，那么在每一处需要建立映射的代码中，都需要重复编写“检查上一级->分配->清零->链接”的样板代码。合并在 `get_pte` 中符合 DRY 原则。

***

# 实验知识点与操作系统原理知识点的对应与分析

## 1. 本实验中重要的知识点及其与OS原理的对应关系

在本实验中，我们从代码层面实现了操作系统中“执行流”的基本管理。以下是实验中的关键实现与OS原理中对应概念的分析：

### 1.1 进程控制块 (PCB) 与 `struct proc_struct`

* **实验中的知识点**：

  * **代码体现**：`kern/process/proc.h` 中的 `struct proc_struct`。

  * **实现细节**：包含 `state`（状态）、`pid`（标识符）、`kstack`（内核栈）、`context`（上下文）、`parent`（父进程指针）等成员。

* **OS原理中的知识点**：

  * **概念**：进程控制块 (Process Control Block, PCB)。

  * **含义**：操作系统用于描述进程当前状态和控制进程运行的所有信息的数据结构，是进程存在的唯一标志。

* **理解与差异**：

  * **关系**：`proc_struct` 就是 uCore 对 PCB 的具体实现。

  * **差异**：

    * **线程 vs 进程**：在 OS 原理中，进程是资源分配单位，线程是调度单位。

    * **复杂性**：原理中的 PCB 通常包含文件描述符表、信号处理、记账信息等，而 Lab 4 的 `proc_struct` 相对精简，仅包含了调度的核心要素。

### 1.2 上下文切换与 `switch_to`

* **实验中的知识点**：

  * **代码体现**：`kern/process/switch.S` 中的 `switch_to` 函数。

  * **实现细节**：利用 RISC-V 的 `STORE` 和 `LOAD` 指令，保存当前进程的 `ra` (返回地址), `sp` (栈指针), `s0-s11` (被调用者保存寄存器) 到原进程的 `context` 中，并从新进程的 `context` 恢复这些寄存器。

* **OS原理中的知识点**：

  * **概念**：上下文切换。

  * **含义**：CPU 从一个进程/线程切换到另一个进程/线程的过程，涉及保存当前 CPU 状态和恢复另一个 CPU 状态。

* **理解与差异**：

  * **关系**：`switch_to` 实现了原理中“保存现场”和“恢复现场”的核心动作。

  * **差异**：

    * **寄存器选择**：原理上通常笼统地称为“保存寄存器”。但在 Lab 4 的实现中，我们清晰地看到**不需要保存所有寄存器**。根据 RISC-V 的调用约定，由调用者保存 (Caller-saved) 的寄存器在调用 `switch_to` 前已被编译器处理或不再需要，因此 `switch_to` 只需要保存被调用者保存 (Callee-saved) 的寄存器。这是理论到工程实现的具体优化。

### 1.3 内核线程的创建与 `do_fork`

* **实验中的知识点**：

  * **代码体现**：`kern/process/proc.c` 中的 `do_fork` 函数以及 `kern/process/entry.S` 中的 `kernel_thread_entry`。

  * **实现细节**：分配 PID，分配内核栈，复制/设置上下文（将 `ra` 设置为 `forkret`，`sp` 指向新栈），加入进程链表。

* **OS原理中的知识点**：

  * **概念**：进程/线程创建与 Fork 操作。

  * **含义**：创建一个新进程，通常涉及资源的复制（如地址空间）或共享（如线程共享内存）。

* **理解与差异**：

  * **含义**：`do_fork` 对应原理中的 `fork()` 系统调用的核心逻辑。

  * **差异**：

    * **地址空间**：原理中的 `fork()` 通常意味着进程地址空间的**写时复制**。但在 Lab 4 中，创建的是内核线程，它们直接共享内核的页表，没有独立的用户地址空间复制过程，因此比标准的进程 `fork` 轻量得多。

    * **入口点**：Lab 4 通过精巧的栈构造（构建 `trapframe`），使得新线程“伪装”成从中断返回的样子，或者利用 `forkret` 跳转到 `kernel_thread_entry`，展示了理论中“构造初始执行环境”的具体手段。

### 1.4 进程调度与 `schedule`

* **实验中的知识点**：

  * **代码体现**：`kern/schedule/sched.c` 中的 `schedule` 函数。

  * **实现细节**：遍历 `proc_list`，寻找状态为 `PROC_RUNNABLE` 的进程，遵循 FIFO (First In First Out) 的简单逻辑。

* **OS原理中的知识点**：

  * **概念**：调度算法。

  * **含义**：决定哪个就绪进程将获得 CPU 时间的策略（如 FIFO, Round Robin 等）。

* **理解与差异**：

  * **关系**：`schedule` 函数是调度器的具体实现，Lab 4 采用的是非抢占式的 FIFO 策略。

  * **差异**：原理中讨论了时间片轮转 (RR)、多级反馈队列 (MLFQ) 等复杂算法。Lab 4 的实现非常基础，主要为了打通“切换”的流程，尚未包含时间片管理和优先级倒置处理等高级特性。

## 2. OS原理中很重要，但在实验中没有对应上的知识点

本实验主要关注内核线程的基础架构，因此许多现代操作系统的高级特性尚未涉及：

1. **用户态与内核态的隔离与切换**

   * **原理**：操作系统通过特权级保护内核。进程运行在用户态，系统调用或中断时进入内核态。

   * **缺失**：Lab 4 的所有线程（idle, init）都运行在内核态（RISC-V 的 S-Mode）。

2. **进程间通信 (IPC) 与 同步互斥**

   * **原理**：进程/线程间需要协作，涉及信号量 (Semaphore)、互斥锁 (Mutex)、管程 (Monitor)、消息队列等机制。

   * **缺失**：虽然代码中有 `local_intr_save` (关中断) 这种最底层的原子操作保证，但没有实现信号量或锁等高层同步原语。线程间目前无法进行复杂的协作或数据安全交换。

3. **高级调度算法与抢占**

   * **原理**：现代 OS 多采用基于时间片的抢占式调度，保证响应时间。

   * **缺失**：Lab 4 的调度更多是协作式的，通常依赖线程主动放弃 CPU（调用 `schedule`）或在特定点切换。FIFO的调度策略也过于简单，效果并不是最好的。

4. **写时复制**

   * **原理**：`fork()` 时不立即复制物理内存，而是共享物理页并将页表设为只读，写操作触发异常时才复制。这是进程创建性能优化的关键。

   * **缺失**：Lab 4 仅涉及内核线程，不涉及用户内存空间的复制，因此完全没有 COW 机制的体现。

5. **死锁处理**

   * **原理**：死锁的预防、避免、检测和恢复。

   * **缺失**：当前系统中资源争用情况极其简单，未引入死锁检测或预防机制。
